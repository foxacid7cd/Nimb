
static void remote_ui_put(UI *ui, const char *cell) {
  UIData *data = ui->data;

  data->client_col++;
  Array args = data->call_buf;
  (*((args).items + ((args).size++)) = (((Object) { .type = kObjectTypeString, .data.string = cstr_as_string((char *)cell) })));
  push_call(ui, "put", args);
}

static void remote_ui_raw_line(UI *ui, Integer grid, Integer row, Integer startcol, Integer endcol,
                               Integer clearcol, Integer clearattr, LineFlags flags,
                               const schar_T *chunk, const sattr_T *attrs) {
  UIData *data = ui->data;

  if (ui->ui_ext[kUILinegrid]) {
    prepare_call(ui, "grid_line");
    data->ncalls++;

    char **buf = &data->buf_wptr;
    mpack_array(buf, 4);
    mpack_uint(buf, (uint32_t)grid);
    mpack_uint(buf, (uint32_t)row);
    mpack_uint(buf, (uint32_t)startcol);
    char *lenpos = mpack_array_dyn16(buf);

    uint32_t repeat = 0;
    size_t ncells = (size_t)(endcol - startcol);
    int last_hl = -1;
    uint32_t nelem = 0;

    for (size_t i = 0; i < ncells; i++) {
      repeat++;

      if (i == ncells - 1 || attrs[i] != attrs[i + 1]
          || strcmp(chunk[i], chunk[i + 1]) != 0) {
        if (4096 - ((size_t)((data)->buf_wptr - (data)->buf)) < 2 * (1 + 2 + sizeof(schar_T) + 5 + 5)) {
          mpack_w2(&lenpos, nelem);
          remote_ui_flush_buf(ui);

          prepare_call(ui, "grid_line");
          data->ncalls++;
          mpack_array(buf, 4);
          mpack_uint(buf, (uint32_t)grid);
          mpack_uint(buf, (uint32_t)row);
          mpack_uint(buf, (uint32_t)startcol + (uint32_t)i - repeat + 1);
          lenpos = mpack_array_dyn16(buf);
          nelem = 0;
          last_hl = -1;
        }

        uint32_t csize = (repeat > 1) ? 3 : ((attrs[i] != last_hl) ? 2 : 1);
        nelem++;
        mpack_array(buf, csize);
        mpack_str(buf, (const char *)chunk[i]);

        if (csize >= 2) {
          mpack_uint(buf, (uint32_t)attrs[i]);

          if (csize >= 3) {
            mpack_uint(buf, repeat);
          }
        }

        last_hl = attrs[i];
        repeat = 0;
      }
    }

    if (endcol < clearcol) {
      nelem++;
      mpack_array(buf, 3);
      mpack_str(buf, " ");
      mpack_uint(buf, (uint32_t)clearattr);
      mpack_uint(buf, (uint32_t)(clearcol - endcol));
    }

    mpack_w2(&lenpos, nelem);
  } else {
    for (int i = 0; i < endcol - startcol; i++) {
      remote_ui_cursor_goto(ui, row, startcol + i);
      remote_ui_highlight_set(ui, attrs[i]);
      remote_ui_put(ui, (const char *)chunk[i]);

      if (utf_ambiguous_width(utf_ptr2char((char *)chunk[i]))) {
        data->client_col = -1;
      }
    }

    if (endcol < clearcol) {
      remote_ui_cursor_goto(ui, row, endcol);
      remote_ui_highlight_set(ui, (int)clearattr);

      if (clearattr == 0 && clearcol == Columns) {
        Array args = {
          .size = 0, .capacity = 0, .items = ((void *)0)
        };
        push_call(ui, "eol_clear", args);
      } else {
        for (Integer c = endcol; c < clearcol; c++) {
          remote_ui_put(ui, " ");
        }
      }
    }
  }
}
